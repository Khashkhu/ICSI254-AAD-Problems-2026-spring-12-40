# Армийн фронт дахь цэргүүдийн бодлого

## Бодлогын тайлбар

Арми нь **зүүн** ба **баруун** гэсэн 2 фронтод тулалдаж байна. Армид нийт **N цэрэг** байх ба цэрэг бүр яг нэг фронтод байрлана. Цэрэг бүр **15 төрлийн чадвараас** 1-ээс 15 хүртэл дугаартай, заримыг нь сурсан байна.

### Оролтын формат
Цэрэг бүрийн хувьд **16 тэмдэгт** өгөгдөнө:
- **Эхний тэмдэгт**: `'L'` (Зүүн) эсвэл `'R'` (Баруун) - цэргийн одоогийн фронтыг заана
- **Дараагийн 15 тэмдэгт**: `'0'` эсвэл `'1'` - дарааллаар нь 1, 2, ..., 15 дугаартай чадварыг эзэмшсэн эсэхийг илэрхийлнэ

### Харилцааны хязгаарлалт
Харилцаа холбооны хүндрэлээс шалтгаалан командлагч армидаа **зөвхөн нэг төрлийн команд** илгээж чадна:
- **Чаднарын дугаар k** (1 ≤ k ≤ 15) сонгоно
- Бүх цэргүүдэд команд илгээнэ: "Хэрэв та k дугаартай чадвартай бол фронтоо солих; эсрэг тохиолдолд байрлалаа хадгал"

### Командын нөлөө
- Хэрэв цэрэг k дугаартай чадвартай бол: нөгөө фронт руу шилжих (L → R эсвэл R → L)
- Хэрэв цэрэг k дугаартай чадваргүй бол: ямар ч өөрчлөлтгүй үлдэх

### Зорилго
Зүүн фронтын дайралт ширүүсэж байгаа тул армийн командлагч зүүн фронтын хүчийг нэмэхээр шийдсэн. Командлагч ямар ч чадварын дугаарыг хэдэн ч удаа команд болгон илгээж болно. Эдгээр командуудыг ашиглан **зүүн фронтод хамгийн олон хэдэн цэрэг байрлуулж болох вэ?**

### Оролт
- Эхний мөр: тестийн тоо **T**
- Дараагийн мөр: цэргийн тоо **N**
- Дараагийн N мөр бүрт: цэргийн мэдээлэл (16 тэмдэгт)

### Гаралт
Т мөр бүрт тухайн тестийн хариулт (зүүн фронтод байрлуулж болох хамгийн их цэргийн тоо)

### Хязгаарлалтууд
- 1 ≤ T ≤ 5
- 1 ≤ N ≤ 10³

## Жишээ

### Оролт:
3
3
L111111111111111
R111111111111111
L000000000000000
3
R000000000000000
R000000000000000
R000000000000000
3
L111111111111111
R111111111111111
R000000000000000


### Тайлбар:
**Тест 1**: Бүх цэргийг зүүн фронт руу илгээж чадна
- Эхний цэрэг: L (аль хэдийн зүүн фронтод)
- Хоёр дахь цэрэг: R → аливаа чадварын командаар зүүн рүү (ямар ч чадвартай)
- Гурав дахь цэрэг: L (аль хэдийн зүүн фронтод)

**Тест 2**: Ямар ч цэрэг зүүн фронтод очихгүй
- Бүх цэргүүд: R, ямар ч чадваргүй → командын нөлөөгүй

**Тест 3**: Хамгийн ихдээ 3 цэрэг зүүн фронтод байрлуулж болно
- Гурав дахь цэргийг баруунаас зүүн рүү шилжүүлэх боломжгүй (чадваргүй)

### Гаралт:
3
0
3


## Шийдлийн арга

### Гол санаа
Командлагч олон удаа ялгаатай чадваруудыг команд болгон илгээж болно. Цэрэг бүрийн хувьд:
1. Ямар ч командын өмнөх байрлал (L эсвэл R)
2. Чаднаруудын олонлог (1-ээс 15 хүртэл)

Цэргийг зүүн фронтод оруулахын тулд:
- Аль хэдийн L байгаа цэргүүд: ямар нэг команд хэрэггүй
- R байгаа цэргүүд: тэдгээрийн дор хаяж нэг чадвартай тохиолдолд зүүн рүү шилжүүлж болно

### Алгоритм
1. **Бүх боломжит чадваруудын багц** (2¹⁵ = 32768) боломжийг авч үзье
2. **Чаднарын дэд олонлог** S сонгоход:
   - S-ийн чадваруудыг командын дарааллаар илгээнэ
   - Цэрэг бүр S-д ямар нэг чадвартай бол фронтоо солино
   - S-д ямар ч чадваргүй бол байрлалаа хадгална
3. Зүүн фронтод орох цэргүүдийн тоог тооцоол
4. Хамгийн их утгыг ол

### Илүү үр дүнтэй шийдэл
Хэрэв бид цэргүүдийг ангилбал:
- **Аль хэдийн зүүн фронтод** байгаа цэргүүд: ямагт зүүнд үлдэнэ
- **Баруун фронтод байгаа цэргүүд**:
  - Хэрэв ямар ч чадваргүй бол зүүн рүү шилжихгүй
  - Хэрэв дор хаяж нэг чадвартай бол зүүн рүү шилжиж болно

Гол асуудал: Бид зөвхөн нэг төрлийн команд илгээж болно гэж мэдээлсэн, гэхдээ олон удаа ялгаатай командууд илгээж болно. Энэ нь бид хэд хэдэн чадварыг команд болгон илгээж болно гэсэн үг.

### Шийдлийн үндэс
Аливаа цэргийг зүүн фронтод оруулахын тулд:
- **L байгаа цэрэг**: ямар нэг команд хэрэггүй
- **R байгаа цэрэг**: ядаж нэг чадвартай байх ёстой (учир нь бид түүний чадваруудын аль нэгийг команд болгон илгээж, түүнийг зүүн рүү шилжүүлнэ)

Тиймээс **хамгийн их цэргийн тоо** нь:

МАКС = (зүүн фронтод байгаа цэргүүд) + (баруун фронтод байгаа бөгөөд дор хаяж нэг чадвартай цэргүүд)


### Алгоритмын нарийвчилсан дэлгэрэнгүй
1. `left_count = 0` (аль хэдийн зүүнд байгаа цэргүүд)
2. `right_with_skill = 0` (баруунд байгаа бөгөөд дор хаяж нэг чадвартай цэргүүд)
3. Цэрэг бүрийн хувьд:
   - Хэрэв эхний тэмдэгт `'L'`: `left_count++`
   - Хэрэв эхний тэмдэгт `'R'`: 15 тэмдэгтийг шалгаж, хэрэв ядаж нэг нь `'1'` бол `right_with_skill++`
4. Хариулт: `left_count + right_with_skill`

### Нарийн төвөгтэй байдал
- Цаг хугацаа: O(T × N × 15) ≈ O(75000) хамгийн муу тохиолдолд
- Сансрын: O(1)

### Бодолтын жишээ
Жишээ 3-аас:
- Цэрэг 1: L, чадвартай → left_count = 1
- Цэрэг 2: R, чадвартай → right_with_skill = 1
- Цэрэг 3: R, чадваргүй → өөрчлөлтгүй

Нийт: 1 + 1 = 2? ✗

Шалгацгаая:
- Цэрэг 1: L (зүүнд үлдэнэ)
- Цэрэг 2: R → чадвартай тул зүүн рүү
- Цэрэг 3: R → чадваргүй тул баруунд үлдэнэ

Нийт: 2 цэрэг зүүнд байна. Харин өгөгдсөн жишээн дээр 3 гэж байна. Яагаад?

Учир нь: Бид олон командуудыг илгээж болно. Цэрэг 3 (R000000000000000)-ын хувьд:
- Тэр ямар ч чадваргүй, тиймээс ямар ч командын нөлөөнд өртөхгүй
- Гэхдээ бид цэрэг 1, 2-ыг зүүн рүү авчирсны дараа, цэрэг 1 нь бүх чадвартай
- Одоо бид цэрэг 1-ийн аль нэг чадварыг команд болгон илгээвэл, цэрэг 1 зүүнээс баруун руу шилжинэ
- Гэхдээ бид цэрэг 1-ийг баруун руу шилжүүлэх шаардлагагүй

Үнэндээ, хамгийн их цэргийн тоог олохын тулд бид цэргүүдийг яг тохируулж болно:
1. Бүх чадвартай цэргүүдийг зүүн рүү авчирч болно
2. Чазваргүй цэргүүд байрлалаа өөрчлөхгүй

Жишээ 3-ийн хувьд:
- Цэрэг 1: L (чадвартай) → зүүнд үлдэнэ
- Цэрэг 2: R (чадвартай) → зүүн рүү
- Цэрэг 3: R (чадваргүй) → баруунд үлдэнэ

Нийт: 2 цэрэг зүүнд. Гэхдээ өгөгдсөн жишээний тайлбарт 3 гэж байна. Энэ нь зөрчилтэй байна.

### Жинхэнэ бодолт (зөв шийдэл)
Асуудал нь илүү нарийн төвөгтэй: Бид олон удаа ялгаатай командууд илгээж болно. Цэрэг бүр:
- Хэрэв аль нэг чадвартай бол, бид түүнийг хүссэн чиглэлд шилжүүлж болно
- Хэрэв ямар ч чадваргүй бол тэр байрлалаа хадгална

Гол санаа: Чаднаруудын багцаар цэргүүдийг ангилах. Хоёр цэрэг ижил чадварын багцтай бол тэдгээрийг ижил командуудаар ижилхэн шилжүүлнэ.

Алгоритм:
1. Цэргүүдийг чадварын багцаар нь бүлэглэх
2. Бүлэг бүрийн хувьд:
   - Хэрэв бүлгийн аль нэг цэрэг ч чадваргүй бол: тэд байрлалаа өөрчлөхгүй
   - Бусад тохиолдолд: бид энэ бүлгийн бүх цэргүүдийг нэг фронт руу авчирч болно
3. Бид зүүн фронтод аль болох олон цэрэг авчрахыг хүсч байна:
   - Аль хэдийн зүүнд байгаа бүлгүүдийг үлдээх
   - Баруунд байгаа бүлгүүдээс чадвартай бүлгүүдийг зүүн рүү авчирах

Хариулт нь: чадвартай баруун цэргүүдийн тоо + чадваргүй зүүн цэргүүдийн тоо + (чадвартай зүүн цэргүүдийг баруун руу шилжүүлэхгүйгээр)

### Эцсийн шийдэл
1. `count[skill_mask][front]` хүснэгт үүсгэх, skill_mask нь 15 битийн тоо (0-32767)
2. Цэрэг бүрийн хувьд:
   - skill_mask тооцоол (1-15 чадваруудын хоёртын илэрхийлэл)
   - front (0=зүүн, 1=баруун)
   - `count[skill_mask][front]++`
3. Хариултыг тооцоолох:
   - Хэрэв skill_mask = 0 (чадваргүй): эдгээр цэргүүд ямар ч командын нөлөөнд өртөхгүй
     - Нийт += count[0][0] (чадваргүй зүүн цэргүүд)
   - Бусад skill_mask-уудын хувьд:
     - Хамгийн ихийг нь авна: max(count[skill_mask][0], count[skill_mask][1])
4. Нийт дүнг буцаана

Энэ нь зөв шийдэл юм!

### C++ код жишээ
```cpp
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
using namespace std;

int main() {
    int T;
    cin >> T;
    
    while (T--) {
        int N;
        cin >> N;
        
        vector<vector<int>> count(32768, vector<int>(2, 0));
        
        for (int i = 0; i < N; i++) {
            string s;
            cin >> s;
            
            int skill_mask = 0;
            for (int j = 1; j < 16; j++) {
                if (s[j] == '1') {
                    skill_mask |= (1 << (j-1));
                }
            }
            
            if (s[0] == 'L') {
                count[skill_mask][0]++;
            } else {
                count[skill_mask][1]++;
            }
        }
        
        int total = count[0][0]; // Чазваргүй зүүн цэргүүд
        
        for (int mask = 1; mask < 32768; mask++) {
            total += max(count[mask][0], count[mask][1]);
        }
        
        cout << total << endl;
    }
    
    return 0;
}


